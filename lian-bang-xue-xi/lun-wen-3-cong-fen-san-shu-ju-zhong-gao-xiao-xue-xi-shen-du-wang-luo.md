# 论文3-从分散数据中高效学习深度网络

原文地址：[从分散数据中高效学习深度网络](https://arxiv.org/abs/1602.0562%20)

## 摘要

现代移动设备拥有丰富的适合学习模型的数据，可以极大地改善用户在设备上的体验。例如，语言模型可以改进语音识别和文本输入，图像模型可以自动选择好的照片。然而，这些丰富的数据通常是隐私敏感的，数量很大，或者两者都有，这可能会阻止登录到数据中心并使用传统方法在那里进行培训。我们提倡一种替代方法，将训练数据分散在移动设备上，通过聚合本地计算的更新来学习共享模型。我们将这种分散的方法称为联邦学习。

我们提出了一种基于迭代模型平均的深度网络联邦学习方法，并对5种不同的模型架构和4个数据集进行了广泛的经验评估。这些实验表明，该方法对于不平衡和非iid数据分布\(这是该设置的一个定义特征\)是健壮的。通信成本是主要的约束条件，与同步随机梯度下降相比，我们显示所需的通信轮数减少了10 - 100倍。

## 1 介绍

手机和平板电脑逐渐成为许多人的主要计算设备\[30.2\]。这些设备上强大的传感器\(包括摄像头、麦克风和全球定位系统\)，加上它们经常被携带，意味着它们可以访问前所未有的大量数据，其中大部分是私人的。从这些数据中学习到的模型具有通过支持更智能的应用程序大大提高可用性的前景，但数据的敏感性意味着将其存储在集中位置存在风险和责任。

我们研究了一种学习技术，该技术允许用户从这些丰富的数据中训练出来的共享模型中获得好处，而不需要集中存储这些数据。我们将我们的方法称为联邦学习，因为学习任务是通过参与设备\(我们称为客户机\)的松散联邦来解决的，这些设备由中央服务器协调。每个客户端都有一个从未上传到服务器的本地训练数据集。相反，每个客户机计算由服务器维护的当前全局模型的更新，并且只有这个更新被通信。这是对2012年白宫消费者数据隐私报告\[39\]提出的集中收集或数据最小化原则的直接应用。由于这些更新是专门用于改进当前模型的，因此一旦应用了它们，就没有理由存储它们。

这种方法的一个主要优点是将模型训练与直接访问原始训练数据的需要分离开来。显然，仍然需要对协调培训的服务器有一定的信任。然而，对于可以根据每个客户机上的可用数据来指定训练目标的应用程序，联邦学习可以通过将攻击面限制在设备而不是设备和云上，从而显著降低隐私和安全风险。

我们的主要贡献是：1\)将基于移动设备分散数据的训练问题确定为一个重要的研究方向；2\)选择一个可以应用于此设置的简单而实用的算法；3\)对提出的方法进行广泛的实证评估。更具体地说，我们引入了FederatedAveraging算法，它将每个客户端上的局部随机梯度下降\(SGD\)与一个执行模型平均化的服务器相结合。我们对该算法进行了大量的实验，证明它对不平衡和非iid数据分布具有鲁棒性，并且可以减少在分散数据上训练深度网络所需的通信轮数。

**联邦学习** 想象中的问题有以下特性：1\)对来自移动设备的真实数据进行训练，比对数据中心中通常可用的代理数据进行训练具有明显的优势。2\)该数据属于隐私敏感数据或数据量较大\(相对于模型的大小而言\)，因此最好不要纯粹为了模型训练\(服务于集中收集原则\)而将其记录到数据中心。3\)对于监督任务，数据上的标签可以从用户交互中自然推断出来。

许多支持移动设备智能行为的模型都符合上述标准。举两个例子，我们考虑图像分类，例如预测哪些照片在未来最有可能被多次浏览或共享；还有语言模型，它可以通过改进解码、下一个单词预测，甚至预测整个回复\[10\]来改善语音识别和触摸屏键盘上的文本输入。这两项任务的潜在训练数据\(用户拍摄的所有照片以及他们在手机键盘上输入的所有内容，包括密码、url、信息等\)可能是隐私敏感的。这些例子的分布也很可能与容易获得的代理数据集有很大的不同：聊天和文本信息中语言的使用通常与标准语言语料有很大的不同，例如维基百科和其他网络文档；人们在手机上拍摄的照片可能与典型的Flickr照片非常不同。最后，这些问题的标签是直接可用的：输入的文本是自我标记的学习语言模型，照片标签可以通过用户与他们的照片应用程序的自然交互定义\(哪些照片被删除、共享或查看\)。

这两种任务都非常适合学习神经网络。对于图像分类，前馈深度网络，特别是卷积网络，众所周知能够提供最先进的结果\[26,25\]。对于语言建模任务，循环神经网络，特别是LSTMs，已经取得了最先进的成果\[20,5,22\]。

**隐私** 与数据中心的持久化数据培训相比，联邦学习具有明显的隐私优势。即使持有一个“匿名”数据集，通过与其他数据\[37\]连接，仍然会使用户的隐私面临风险。相比之下，为联邦学习传输的信息是改进特定模型所需的最小更新\(自然，隐私好处的强度取决于更新的内容\)。更新本身可以\(也应该\)是短暂的。它们永远不会包含更多的信息比原始的训练数据\(由数据处理不平等得来\)，一般会包含得少得多。此外，聚合算法不需要更新源，因此更新可以在不识别元数据的情况下通过Tor\[7\]等混合网络或通过可信的第三方进行传输。本文最后简要讨论了联合学习与安全多方计算和差分隐私相结合的可能性。

**联邦优化** 我们将联邦学习中隐含的优化问题称为联邦优化，将其与分布式优化联系起来\(并进行对比\)。联邦优化与典型的分布式优化问题有几个关键的区别：

* **非独立相似分布（independent identically distributed\)** 数据通常基于特定用户对移动设备的使用，因此任何特定用户的本地数据集都不能代表总体分布。
* **不平衡** 类似地，一些用户会比其他人更频繁地使用服务或应用程序，从而导致本地训练数据的数量发生变化。
* **大规模分布式** 我们希望参与优化的客户端数量比每个客户端的平均示例数量要多。
* **通信受限** 移动设备经常离线或链接缓慢昂贵。

在本文中，我们的重点是优化的非iid和不平衡性，以及通信约束的关键性质。部署的联邦优化系统还必须解决大量的实际问题：随着数据的添加和删除而变化的客户机数据集；以复杂的方式与本地数据分布相关的客户可用性\(例如，来自美式英语的电话可能会在不同的时间插入，而不是来自英式英语的电话\)；客户端从不响应或发送损坏的更新。

这些问题超出了目前工作的范围；相反，我们使用一个受控制的环境，它适合于实验，但仍然解决了客户机可用性和不平衡和非iid数据的关键问题。我们假设同步更新方案在通信中进行。有一个固定的K个客户端集合，每个客户端都有一个固定的本地数据集。在每一轮的开始，选择客户端的一个随机分数C，服务器将当前的全局算法状态发送给每个客户端\(例如，当前的模型参数\)。为了提高效率，我们只选择了一小部分客户，因为我们的实验表明，增加更多客户超过某个点，回报就会递减。然后，每个选定的客户机根据全局状态及其本地数据集执行本地计算，并向服务器发送更新。然后服务器将这些更新应用到其全局状态，然后重复此过程。

当我们专注于非凸神经网络目标时，我们所考虑的算法适用于任何形式的有限和目标从

$$
\mathop{min}\limits_{w\in{R^d}}f(w) \qquad f(w)\mathop=\limits^{def}\frac1n\sum_{i=1}^nf_i(w)
$$

对机器学习的问题,我们通常采取$f\_i\(w\)=l\(x\_i,y\_i,w\)$，也就是说在例子$\(x\_i,y\_i\)$的损失预测是有模型参数w造成的。我们假设有K客户/数据分区,$P\_k$组索引的数据点在客户K, $n\_k=\|P\_k\|$。因此，我们可以将目标\(1\)改写为

$$
f(w)=\sum_{k=1}^K\frac{n_k}nF_kw \qquad F_kw=\frac1{n_k}\sum_{i\in{P_k}}f_i(w)
$$

如果将训练样本均匀地随机分布在客户端上形成划分pk，那么我们将得到$E\_{P\_k}\[F\_k\(w\)\] = f\(w\)$，其中期望是分配给固定客户端k的一组样本。这是分布式优化算法通常做出的IID假设；我们将这种不成立的情况\(也就是说，$F\_k$可能是f的任意糟糕近似值\)作为非iid设置。

在数据中心优化中，通信成本相对较小，计算成本占主导地位，最近的重点是使用gpu来降低这些成本。相比之下，在联邦优化中通信成本占主导地位——我们通常会受到1 MB/s或更少上传带宽的限制。此外，客户通常只会在充电、上网和无计量wi-fi连接时自愿参与优化。此外，我们希望每个客户端每天只参与少量的更新轮。另一方面，由于任何单个设备上的数据集与总体数据集大小相比都很小，而且现代智能手机拥有相对较快的处理器\(包括gpu\)，与许多模型类型的通信成本相比，计算基本上是免费的。因此，我们的目标是使用额外的计算，以减少训练模型所需的通信轮数。有两种主要的方法可以增加计算量：1\)增加并行度，即在每一轮通信中使用更多的客户端独立工作；并且，2\)在每个客户端上增加计算量，而不是执行像梯度计算这样的简单计算，每个客户端在每一轮通信之间执行更复杂的计算。我们研究了这两种方法，但是我们实现的加速主要是由于在客户机上使用了最低级别的并行性后，在每个客户机上添加了更多的计算。

**相关工作**  McDonald等人对感知器进行了局部训练模型迭代平均的分布式训练Povey等人发表了DNNs的识别。Zhang等人研究了一种具有“软”平均的异步方法。这些工作只考虑集群/数据中心设置\(最多16个工作者，基于快速网络的时钟时间\)，而不考虑不平衡和非iid的数据集，这些属性对于联邦学习设置是至关重要的。我们将这种算法风格适应于联邦设置，并执行适当的经验评估，这提出了与数据中心设置相关的不同的问题，需要不同的方法。

基于与我们类似的动机，Neverova等人也讨论了在设备上保存敏感用户数据的好处。Shokri和Shmatikov\[35\]的工作有几个方面的关联：他们专注于训练深度网络，强调隐私的重要性，通过在每一轮通信中只共享参数的子集来解决通信成本；然而，他们也没有考虑不平衡和非iid数据，实证评价是有限的。

在凸设置中，分布式优化和估计问题受到了极大的关注\[4,15,33\]，一些算法确实专门关注通信效率\[45,34,40,27,43\]。除了假设凸性之外，现有的工作通常要求客户机的数量要比每个客户机的示例数量少得多，数据以IID的方式分布在客户机之间，并且每个节点有相同数量的数据点-在联邦优化设置中违反了所有这些假设。SGD的异步分布式形式也被应用于训练神经网络，例如，Dean等人\[12\]，但这些方法在联邦设置中需要大量的更新。分布式共识算法\(例如\[41\]\)放宽了IID假设，但仍然不适合在很多客户端上进行通信约束优化。

我们考虑的\(参数化\)算法家族的一个端点是简单的一次性平均，其中每个客户端求解的模型使其局部数据的损失最小化\(可能是正则化的\)，这些模型被平均以产生最终的全局模型。这种方法已经在IID数据的凸情况下进行了广泛的研究，众所周知，在最坏的情况下，产生的全局模型并不比在单个客户端上训练模型更好\[44,3,46\]。

## 2 federated平均化算法

最近大量成功的深度学习应用几乎完全依赖于随机梯度下降\(SGD\)的变量进行优化；事实上，许多进步可以理解为调整模型的结构\(以及损失函数\)，使其更易于通过简单的基于梯度的方法\[16\]进行优化。因此，我们很自然地从SGD开始构建迭代优化算法。

SGD可以简单地应用于联邦优化问题，即在每轮通信中进行单个批梯度计算\(比如在随机选择的客户机上\)。这种方法的计算效率很高，但需要大量的训练才能产生好的模型\(例如，即使使用批归一化这样的高级方法，Ioffe和Szegedy\[21\]对MNIST进行了50000步的小批量训练\)。我们在CIFAR-10实验中考虑了这一基线。

在联邦设置中，涉及更多客户机的时钟时间成本很小，因此对于我们的基线，我们使用大批量同步SGD；Chen等人\[8\]的实验表明，这种方法在数据中心设置方面是最先进的，在这方面它优于异步方法。为了在联邦设置中应用这种方法，我们在每一轮中选择客户端的C分数，并计算这些客户端持有的所有数据的损失梯度。因此，C控制全局批大小，C = 1对应全批\(非随机\)梯度下降。我们将这个基线算法称为FederatedSGD\(或FedSGD\)。

FedSGD的一个典型实现是C = 1和固定学习率η，每个客户端k都计算$g_k=\nabla F\_k\(w\_t\) $，即当前模型wt下其本地数据的平均梯度，中心服务器将这些梯度聚合，并应用更新$w_{t+1}\leftarrow w_t-\eta \sum_{k=1}^K\frac{n_k}{n}g\_k,since \sum_{k=1}^K \frac{n_k}{n}g\_k = \nabla f\(w\_t\)$。一个等价的更新由$\forall k,w_{t+1}^k\leftarrow w_t-\eta g\_k,w\_t+1\leftarrow\sum_{k=1}^K\frac{n_k}{n}w_{t+1}^k$。也就是说，每个客户端使用其本地数据在当前模型上进行一个梯度递减步骤，然后服务器对结果模型进行加权平均。

一旦算法以这种方式编写，我们就可以通过在平均步骤之前多次迭代本地更新$w^k \leftarrow w^k-\eta \nabla F\_k\(w^k\)$来为每个客户端增加更多的计算量。我们将这种方法称为federated平均化\(或FedAvg\)。计算量由三个关键参数控制:C，每轮执行计算的客户端比例；E，然后每个客户端在每轮上通过其本地数据集的训练次数；B，用于客户端更新的本地小批大小。我们写$B=\infty$表示完整的本地数据集被当作单个的小批量处理。因此，在这个算法族的一个端点上，我们可以取$B=\infty$，E = 1，这恰好对应于FedSGD。对于具有$n\_k$本地示例的客户端，每轮本地更新的数量由$u\_k=E\frac{n\_k}{B}$给出；完整的伪代码在算法1中给出。

对于一般的非凸目标，参数空间的平均模型可能产生任意不良的模型。

按照Goodfellow et al.\[17\]的方法，当我们对从不同初始条件训练出来的两个MNIST数字识别模型s33进行平均时，我们确实看到了这种不良行为\(图1，左\)。对于这个图，母模型w和w0分别在来自MNIST训练集中600个样本的非重叠IID样本上进行训练。训练是通过SGD进行的，对于规模为50的小批量\(或E = 20通过规模为600的小数据集\)的240次更新，固定学习率为0.1。这大约是模型开始过拟合其局部数据集时的训练量。

![image-20210425151219897](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/figure-1)

图1:对50个等间距的值$\theta \in \[-0.2,1.2\]$，使用$\theta \_w+\(1-\theta\)w^{'}$对两个模型的参数w和$w^{'}$求平均值所产生的模型在完整MNIST训练集上的损失。在不同的小数据集上使用SGD对模型w和$w^{'}$进行训练。左侧小区使用不同的随机种子对w和$w^{'}$进行初始化；对于合适的地块，使用共享的种子。注意不同的y轴尺度。水平线给人最好的损失通过w或$w^{'}$\(很近,对应于垂直线θ= 0和θ= 1\)。与初始化共享,平均模型产生显著减少损失总训练集\(相比失去父母模型\)。

最近的研究表明，在实践中，充分过参数化的神经网络的损失面表现得出奇地好，特别是比以前认为的更不容易出现糟糕的局部极小值\[11,17,9\]。事实上，当我们从相同的随机初始化开始两个模型，然后再次分别训练不同的数据子集时\(如上所述\)，我们发现简单的参数平均非常有效\(图1，右\):这两个模型的平均值\($\frac{1}{2}w+\frac{1}{2}w^{'}$\)在完整MNIST训练集上获得的损耗显著低于在任何一个小数据集上单独训练得到的最佳模型。虽然图1从一个随机初始化开始，请注意每个FedAvg回合使用的共享启动模型wtis，因此同样的直觉也适用。

算法1 FederatedAveraging。K个客户端被K索引；B为局部小批量大小，E为局部epoch数，η为学习速率。

![image-20210425152053598](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/%E7%AE%97%E6%B3%951.png)

## 3 实验结果

我们的动机是图像分类和语言建模任务，好的模型可以大大提高移动设备的可用性。对于这些任务，我们首先选择了一个足够小的代理数据集，以便我们可以彻底研究FedAvg算法的超参数。虽然每个单独的训练运行相对较小，但我们为这些实验训练了超过2000个单独的模型。然后给出基准CIFAR-10图像分类任务的结果。最后，为了演示FedAvg在客户端数据自然分区的实际问题上的有效性，我们对一个大型语言建模任务进行了评估。

我们最初的研究包括两个数据集上的三个模型家庭。前两个是用于MNIST数字识别任务\[26\]:1\)一个简单的多层感知器，有2个隐藏层，每个层有200个单元，使用ReLu激活\(总参数为199210\)，我们称之为MNIST 2NN。2\)一个具有两个5x5卷积层的CNN\(第一层有32个通道，第二层有64个通道，每个层后面都有2x2 max pooling\)，一个全连接层有512个单元和ReLu激活，最后一个softmax输出层\(总参数1663370\)。为了研究联合优化，我们还需要指定数据如何在客户端上分布。我们研究两种方式MNIST分区数据客户:IID,数据被打乱,然后划分为100个客户收到600例,Non-IID,我们首先对数据排序数字标签,200碎片分成300的大小,分配每个100客户2碎片。这是数据的病态非iid分区，因为大多数客户端只有两位数字的示例。因此，这让我们可以探索我们的算法在高度非iid数据上中断的程度。然而这两个分区是平衡的。

对于语言建模，我们从莎士比亚全集\[32\]中建立了一个数据集。我们为每个剧中的每个说话角色构建一个至少有两行台词的客户数据集。这生成了具有1146个客户端的数据集。对于每个客户端，我们将数据划分为一组训练线\(针对角色的前80%行\)和测试线\(最后20%，四舍五入到至少一行\)。得到的数据集在训练集中有3,564,579个字符，在测试集中有870,014个字符。这个数据基本上是不平衡的，许多角色只有几行，而有些角色有很多行。此外，观察测试集不是一个随机的线条样本，而是由每个戏剧的时间顺序暂时分开的。使用相同的训练/测试分离，我们还形成了数据集的平衡和IID版本，同样有1146个客户端。

在这些数据上，我们训练了一个堆叠的字符级LSTM语言模型，该模型在读取一行中的每个字符后，预测下一个字符\[22\]。该模型以一系列字符作为输入，并将每个字符嵌入到一个8维空间中。然后通过2个LSTM层处理嵌入的字符，每个层有256个节点。最后，第二个LSTM层的输出被发送到每个字符一个节点的softmax输出层。完整的模型有866,578个参数，我们使用80个字符展开长度进行训练。

SGD对学习率参数η的调整非常敏感。研究结果是基于训练的学习在一个足够学习效率\(通常是11 - 13值η的乘法网格分辨率$10^{\frac{1}{3}}$或者$10^{\frac{1}{6}}$\)。我们检查,以确保最好的学习速率是在中间的网格,这没有一个最好的学习效率之间的显著差异。除非另有说明，否则我们将为每个x轴值分别选定的最佳执行率绘制指标。我们发现最优学习率不像其他参数的函数变化太多。

**提高并行性** 我们首先用客户端部分C进行实验，它控制多客户端并行度的数量。表1显示了不同C对两种MNIST模型的影响。我们报告了达到目标测试集精度所需的通信轮数。为了计算这个，我们为每一个参数设置组合构造了一个学习曲线，如上所述优化η，然后通过在所有前一轮中获得测试集精度的最佳值，使每一条曲线单调地改进。然后我们计算曲线与目标精度相交的轮数，使用形成曲线的离散点之间的线性插值。参考图2可以更好地理解这一点，其中的灰色线显示了目标。

![image-20210425154820089](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/figure-2.png)

图2：MNIST CNN \(IID，然后是病理非IID\)和莎士比亚LSTM \(IID，然后是Play&Role\)在C = 0.1和优化η下的测试集精度与通信轮数。灰线表示表2中使用的目标精度。2NN的图见附录A中的图7。

对于B =∞\(MNIST每轮以单个批处理所有600个客户端示例\)，在增加客户端比例方面只有很小的优势。使用更小的批大小B = 10显示了使用C≥0.1的显著改善，特别是在非iid的情况下。基于这些结果，我们在余下的大部分实验中固定C = 0.1，这在计算效率和收敛速度之间达到了很好的平衡。比较B =∞和B = 10列的轮数在表1中显示了一个显著的加速，我们接下来将对此进行研究。

![](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/table-1.jpg)

表1：客户端分数C对E = 1和E = 5的MNIST 2NN和CNN的影响。注意C = 0.0对应每轮一个客户端；因为我们使用100个客户端来处理MNIST数据，所以这些行分别对应于1、10、20、50和100名客户。每个表条目给出了必要的通信轮数，以实现测试集的准确性为2NN的97%，为CNN的99%，以及相对于C = 0基线的加速。在允许的时间内，5次大批量的运行都没有达到目标精度。

**增加每个客户端的计算量** 在本节中，我们固定C = 0.1，并在每一轮中增加每个客户端的计算量，或者减少B，增加E，或者两者都增加。图2表明，每轮增加更多的本地SGD更新可以显著降低通信成本，表2量化了这些加速。每轮每个客户端更新的预期数量是$u=\(E\[n\_k\]/b\),E=nE/\(KB\)$，其中的期望是在随机抽取客户端k之上。我们根据这个统计量对表2中每个部分的行进行排序。我们看到通过改变E和B来增加u是有效的。只要B足够大，能够充分利用客户机硬件上可用的并行性，就基本上不需要花费计算时间来降低它，因此在实践中，这应该是第一个调优的参数。

![image-20210425153835284](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/table-2.png)

表2：与FedSGD相比，FedAvg达到目标精度的通信轮数\(第一行，E = 1, B =∞\)。u列给出u = En/\(KB\)，即每轮更新的预期数量。

对于MNIST数据的IID划分，每个客户端计算的次数越多，为达到目标精度，CNN减少了35×， 2NN减少了46× \(2NN的详细信息见附录A中的表4\)。病理分区的非iid数据的加速较小，但仍然很大\(2.8 - 3.7×\)。这是令人印象深刻的，当我们天真地用完全不同的数字对训练出来的模型参数进行平均时，这种平均提供了任何优势\(实际上是背离\)。因此，我们认为这是该方法稳健性的有力证据。

莎士比亚的不平衡和非iid分布\(根据戏剧中的角色\)更能代表我们在现实应用中所期望的那种数据分布。令人鼓舞的是，对于这个问题，学习非IID和不平衡数据实际上要容易得多\(95×加速比平衡IID数据的13×加速\)；我们推测这很大程度上是因为一些角色有相对较大的局部数据集，这使得增加的局部训练特别有价值。

对于所有三个模型类，FedAvg比基准FedSGD模型收敛到更高水平的测试集精度。这一趋势会持续下去，即使这些线超出了标绘范围。例如，对于CNN, B =∞，E = 1 FedSGD模型在1200轮后最终达到99.22%的精度\(6000轮后没有进一步改善\)，而B = 10, E = 20 FedAvg模型在300轮后达到99.44%的精度。我们推测除了降低通信成本之外，模型平均还产生了类似于dropout\[36\]所获得的正则化收益。

我们主要关注泛化性能，但FedAvg在优化训练损失方面也很有效，甚至超过了测试集精度稳定的点。我们观察到所有三个模型类的相似行为，并在附录a的图6中为MNIST CNN绘制了图6。

**我们可以过度优化客户端数据集吗？**当前的模型参数仅通过初始化影响在每个ClientUpdate中执行的优化。因此，当E→∞时，至少对于凸问题最终初始条件应该是不相关的，并且无论初始化与否都会达到全局最小值。甚至对于一个非凸问题，人们可能会猜想算法只要初始化在同一盆地，就会收敛到相同的局部最小值。也就是说，我们预计一轮平均可能产生一个合理的模型，而额外的几轮通信\(和平均\)不会产生进一步的改进。

图3显示了初始训练中大E对莎士比亚LSTM问题的影响。事实上，对于非常多的局部时期，FedAvg可以趋于稳定或发散这一结果表明，对于某些模型，特别是在收敛的后期阶段，以同样的方式衰减学习速率可能有用的方式衰减每轮的局部计算量\(向较小的E或较大的B移动\)可能是有用的。附录A中的图8给出了MNIST CNN的类似实验。有趣的是，在这个模型中，我们没有看到大值E的收敛速度有明显的下降。然而，我们看到在下面描述的大规模语言建模任务中，E = 1比E = 5的性能稍好一些\(见附录A中的图10\)。

![image-20210425155244854](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/figure3.png)

图3:在平均步骤之间训练许多地方时\(大E\)的效果，固定B = 10和C = 0.1的莎士比亚LSTM与固定的学习速率η = 1.47。

我们还在CIFAR-10数据集\[24\]上进行了实验，以进一步验证FedAvg。该数据集由10类32x32图像组成，有3个RGB通道。有50,000个训练示例和10,000个测试示例，我们将它们划分为100个客户端，每个客户端包含500个训练示例和100个测试示例；因为这个数据没有一个自然的用户分区，所以我们考虑平衡和IID设置。该模型架构取自TensorFlow教程\[38\]，该教程包括两个卷积层，然后是两个完全连接的层，然后是一个产生logit的线性转换层，总共大约有$10^6$个参数。请注意最先进的方法已经实现了对CIFAR的96.5%\[19\]的测试精度；然而，我们使用的标准模型足以满足我们的需求，因为我们的目标是评估我们的优化方法，而不是在这项任务上达到最好的可能精度。图像作为训练输入管道的一部分进行预处理，包括将图像裁剪为24x24，随机左右翻转，调整对比度、亮度和白度。

对于这些实验，我们考虑在完整的训练集\(没有用户分区\)上使用一个额外的基线，标准的SGD训练，使用大小为100的小批。在197500次小批更新之后，我们获得了86%的测试精度\(在联邦设置中，每个小批更新都需要一次通信轮\)。FedAvg在2000轮通信后也达到了85%的测试精度。对于所有算法，我们除了初始学习速率外，还调整了学习速率衰减参数。表3给出了基线SGD、FedSGD和FedAvg达到三个不同精度目标的通信轮数，图4给出了FedAvg与FedSGD的学习率曲线。

![image-20210425155555996](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/table-3.png)

表3:在CIFAR10上达到目标测试集精度相对于基准SGD的轮数和加速。SGD使用的小批量为100。FedSGD和FedAvg采用C = 0.1, FedAvg采用E = 5, B = 50。

![image-20210425155336388](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/figure-4.png)

图4:CIFAR10实验的测试精度与通信。FedSGD每轮的学习率衰减为0.9934；FedAvg使用B = 50，每轮学习率衰减0.99,E = 5。

通过对SGD和FedAvg进行规模为B = 50的小批量实验，我们也可以将精度看作是这种小批量梯度计算数量的函数。我们希望SGD在这里做得更好，因为在每个小批计算之后都要执行一个顺序步骤。然而，正如附录中的图9所示，对于C和E的中等值，FedAvg在每个小批计算中取得了类似的进度。此外，我们还发现，在每轮只有一个客户的标准SGD和FedAvg \(C = 0\)中，都显示出了显著的准确性振荡，而在更多客户的平均情况下，这一点就会变得平滑。

**大规模LSTM实验** 我们在一个大规模下一词预测任务上进行了实验，以证明我们的方法在现实问题上的有效性。我们的训练数据集包括来自一个大型社交网络的1000万条公开帖子。我们按作者对帖子进行分组，总共有50多万客户。此数据集是文本输入数据类型的现实代理，该类型将出现在用户的移动设备上。我们将每个客户数据集限制为最多5000个单词，并在来自不同\(非培训\)作者的1e5篇文章的测试集上报告准确性\(在10000个可能性中，对下一个单词的正确预测概率最高的数据的一部分\)。我们的model是一个基于10,000个单词的词汇表的256个节点LSTM。每个词的输入和输出嵌入维数为192，并与模型进行协同训练；总共有4950544个参数。我们用了10个单词展开。

这些实验需要大量的计算资源，所以我们没有彻底探索超参数:每轮都在200个客户端上进行训练；FedAvg采用B = 8, E = 1。我们研究了FedAvg和基准FedSGD的各种学习率。图5显示了最佳学习率的单调学习曲线。η = 18.0的FedSGD需要820轮才能达到10.5%的准确度，而η = 9.0的FedAvg仅在35发通信轮中达到10.5%的准确度\(比FedSGD少23倍\)。我们观察到FedAvg在测试准确性方面的方差较小，见附录a中的图10。该图还包括E = 5的结果，它的表现略差于E = 1。

![&#x56FE;5](https://gitee.com/zlt_shadow/res/raw/master/images-bed/paper3/figure-5.png)

图5:大规模语言模型词LSTM的单调学习曲线。

## 4 结论与未来工作

我们的实验表明，联邦学习是可行的，因为FedAvg可以用相对较少的轮数来训练高质量的模型，这在多种模型架构上的结果都证明了这一点:一个多层感知器，两个不同的卷积神经网络，一个两层字符LSTM，以及一个大规模的词级LSTM。

虽然联邦学习提供了许多实际的隐私好处，但通过差异隐私\[14,13,1\]、安全多方计算\[18\]或它们的组合提供了更强的保证，这是未来工作的一个有趣方向。请注意，这两类技术最自然地适用于像FedAvg这样的同步算法。

